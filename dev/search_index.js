var documenterSearchIndex = {"docs":
[{"location":"man/internal/#Internal-APIs-for-developers","page":"Internal APIs for developers","title":"Internal APIs for developers","text":"","category":"section"},{"location":"man/internal/","page":"Internal APIs for developers","title":"Internal APIs for developers","text":"Modules = [DynamicQuantumCircuits.Conversion, DynamicQuantumCircuits.Reorder, DynamicQuantumCircuits.QuantumInformation, DynamicQuantumCircuits.Tools, DynamicQuantumCircuits.Transformations]","category":"page"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_ast-Tuple{OpenQASM.Types.MainProgram, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_ast","text":"conv_ast(ast::MainProgram, state_vector::StateVector, num_qubits::Int64)::MainProgram\n\nConverts a non-unitary quantum circuit so it can be tested for equality with  its equivalent a unitary circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_prog-Tuple{Any, StateVector, Int64, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_prog","text":"conv_prog(a::Any, state_vector::StateVector, num_qubits::Int, section::Int)::Any\n\nPattern matches a Prog element and returns it with the new address, based on the conversion from the StateVector\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_qop-Tuple{OpenQASM.Types.CXGate, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_qop","text":"conv_qop(cx::CXGate, state_vector::StateVector, section::Int)::CXGate\n\nConverts the adresses of a CXGate based on the state vector and section in the dynamic circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_qop-Tuple{OpenQASM.Types.Instruction, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_qop","text":"conv_qop(inst::Instruction, state_vector::StateVector, section::Int)::Instruction\n\nConverts the adresses of a quantum operation based on the state vector and section in the dynamic circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_qop-Tuple{OpenQASM.Types.Measure, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_qop","text":"conv_qop(m::Measure, state_vector::StateVector, section::Int)::Measure\n\nConverts the adresses of a Meausment Operation based on the state vector and section in the dynamic circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_qop-Tuple{OpenQASM.Types.Reset, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_qop","text":"conv_qop(r::Reset, state_vector::StateVector, section::Int)::Reset\n\nReturn the Reset Operation unchanged\n\nFIXME check if this is according to specifaction\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.conv_regdecl-Tuple{OpenQASM.Types.RegDecl, Integer}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.conv_regdecl","text":"conv_regdecl(reg::RegDecl, num_qubits::Integer)::RegDecl\n\nSets num_qubits bits as the number of bits in a quantum RegDecl\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.create_bit-Tuple{StateVector, OpenQASM.Types.Bit, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.create_bit","text":"create_bit(state_vector::StateVector, i::Bit)::Bit\n\nCreate a Bit from a the state vector and the old bit adress\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.remove_measurements-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.remove_measurements","text":"remove_measurements(ast::MainProgram)::MainProgram\n\nRemoves all measurements from a quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.remove_resets-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.remove_resets","text":"remove_resets(ast::MainProgram)::MainProgram\n\nRemoves all resets from a quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Conversion.zip_prog_section-Tuple{Vector{Any}}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Conversion.zip_prog_section","text":"zip_prog_section(progs::Vector{Any})\n\nZip the index of each section with a prog element. Increment index after each Measure\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Reorder.calulate_indices-Tuple{StateVector}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Reorder.calulate_indices","text":"calulate_indices(state_vector::StateVector)::Array{Int}\n\nCreate indices for reordering based\n\nExample\n\njulia> calulate_indices(StateVector([1,0], [2]))\nInt8[0, 1, 4, 5, 2, 3, 6, 7]\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Reorder.create_bit_matrix-Tuple{Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Reorder.create_bit_matrix","text":"create_bit_matrix(n::Int)::Matrix{Int}\n\nCreate matrix for all possible n bit combinations\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Reorder.matrix_row_to_bit-Tuple{Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Reorder.matrix_row_to_bit","text":"matrix_row_to_bit(x::Vector{Int})::Int\n\nparses an array of ints as a bit\n\nExample\n\njulia> matrix_row_to_bit([0,1,0])\n2\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Reorder.reorder_columns-Tuple{Any, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Reorder.reorder_columns","text":"reorder_columns(matrix::Matrix{Any}, column_indices::Vector{Int})::Matrix\n\nReorder matrix based on column_indices\n\nExample\n\njulia> n = 3  # Number of bits\njulia> m = create_bit_matrix(n)\njulia> m_reordered = reorder_columns(original_matrix, column_indices)\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Reorder.reorder_operator-Tuple{StateVector, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Reorder.reorder_operator","text":"reorder_operator(operator::Matrix{ComplexF64})::Matrix{ComplexF64}\n\nCalculate the new indices and peform the reordering of an operator\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Reorder.reorder_rows-Tuple{Any, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Reorder.reorder_rows","text":"reorder_rows(operator, indices)::Matrix\n\nReorder the rows of a matrix based on the indices\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.density_matrix-Tuple{Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.density_matrix","text":"density_matrix(matrix)::Matrix\n\nCalculate the density matrix assuming phi is the first quantum state in Z Basis\n\nDefinition\n\nM ϕ ϕ M^dagger\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.fidelity-Tuple{Any, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.fidelity","text":"fidelity(U1, U2)::Float64\n\nFidelity is a measure of distance between quantum states ϕ and ρ\n\nDefinition\n\nThe fidelity of two quantum state for qudits is defined as:\n\nF(ϕ σ) = tr(sqrtsqrtϕρsqrtρ)\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.inner_product-Tuple{Any, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.inner_product","text":"inner_product(x, y)::Vector\n\nCalculate the inner product\n\nExamples\n\nThe product is written as a bra standing on the left and a ket standing on the right, for example,\n\n  βα= (β) (α)\n\nTODO Doctest\n\nSource\n\n(1.46) Quantum Mechanics Book\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.outer_product-Tuple{Any, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.outer_product","text":"outer_product(x, y)::Matrix\n\nDefinition\n\n(β)  (α) = βα\n\nβα is known as the outer product of β and α. We will emphasize in a moment that |β⟩⟨α| is to be regarded as an operator; hence it is fundamentally different from the inner product ⟨β|α⟩, which is just a number.\n\nThere are also “illegal products.” We have already mentioned that an operator must stand on the left of a ket or on the right of a bra.\n\nExamples\n\nTODO Doctest\n\nSource\n\n(1.46) Quantum Mechanics Book\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.qc_trace_distance-Tuple{Any, Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.qc_trace_distance","text":"equality(M, M_prime)::Float64\n\nTest the equality of two matrices by converting them to density matrices and calculating their trace distance\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.tracedist-Tuple{Matrix, Matrix}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.tracedist","text":"tracedist(A::Matrix, B::Matrix)::Float64\n\nReturn the trace distance of register1 and register2.\n\nDefinition\n\nTrace distance is defined as following:\n\nfrac12  A - B _rm tr\n\nExamples\n\nTODO Doctest\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Trace_distance\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.QuantumInformation.verify_equivalence","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.QuantumInformation.verify_equivalence","text":"verify_equivalence(traditional_circuit, dynamic_circuit, use_zx::Bool, transform_dynamic_circuit::Bool)::Float64\n\nVerify the equality of a traditional_circuit and a reconstruced circuit, returning the trace distance and fidelity as a tuple\n\nTODO change api to differentiate between exact and similar qc\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.combine-Tuple{StateVector}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.combine","text":"combine(s::StateVector)::Array{Int}\n\nReturn the combined states of the state vector\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.convert_address-Tuple{StateVector, Int64, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.convert_address","text":"convert_address(state::State, section::Int, address::Int)::Int64\n\nReplaces the address of a qubit based on the state vector, section and position using a lookup table\n\nObjective\n\nThis function converts old addresses into new addresses required for the ideal unitary circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.drop_gate_of_type-Tuple{Any, Type}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.drop_gate_of_type","text":"drop_gate_of_type(arr, gate_type::Type)\n\nFilters any gate which matches the gate type\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.get_controls-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.get_controls","text":"get_controls(ast :: MainProgram)::Array{CXGate}\n\nReturn all control operations of the quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.get_measurements-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.get_measurements","text":"get_measurements(ast :: MainProgram)::Array{Measure}\n\nReturn all measurement operations of the quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.get_num_of_qubits-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.get_num_of_qubits","text":"get_num_of_qubits(ast :: MainProgram)::Int\n\nReturns the number of qubits, which have been specified in the first quantum register\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.prepare_for_ZXCalculus-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.prepare_for_ZXCalculus","text":"prepare_for_ZXCalculus(ast::MainProgram)\n\npreparre for import in the ZXCalculus by removing measurements, barriers and #TODO applying custom gates\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.read_qasm_from_file-Tuple{Any}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.read_qasm_from_file","text":"read_qasm_from_file(filename)::String\n\nRead the qasm from a file\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Tools.state_vector-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Tools.state_vector","text":"state_vector(ast::MainProgram)::StateVector\n\nCreates the reordered StateVector based on the ast of a quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.acts_on-Tuple{Any, OpenQASM.Types.Bit}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.acts_on","text":"acts_on?(operation::Any, qubit::Bit)\n\nDoes the operation act on the qubit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.create_bit-Tuple{StateVector, OpenQASM.Types.Bit, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.create_bit","text":"create_bit(state_vector::StateVector, i::Bit)::Bit\n\nCreate a Bit from a the state vector and the old bit adress\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.defeer_measurements-Tuple{Vector{Any}}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.defeer_measurements","text":"defeer_measurements(prog::Vector{Any})::Vector{Any}\n\nDelay all meausrements to the end and replace phase roations controlled by meausrement outcomes with phase gates controlled by the respective circuits\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.overcome_resets-Tuple{OpenQASM.Types.MainProgram, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.overcome_resets","text":"overcome_resets(ast::MainProgram, state_vector::StateVector, num_qubits::Int64)::Vector{Any}\n\novercomes resets operations by eliminating qubit reuse\n\nThis transforms a n qubit circuit circuit containing r reset operations into a  n+r qubit quantum circuits\n\nAlgorithm\n\nOvercome resets by interpreting a reset as measuring a qubit and applying an X operation  on the measurement being |1⟩ and discarding the measurement result. To overcome the  resets replace by introducing a new qubit and applying subsequent operations involving the  qubit to the new qubit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.remove_measurements-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.remove_measurements","text":"remove_measurements(ast::MainProgram)::MainProgram\n\nRemoves all measurements from a quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.remove_resets-Tuple{OpenQASM.Types.MainProgram}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.remove_resets","text":"remove_resets(ast::MainProgram)::MainProgram\n\nRemoves all resets from a quantum circuit\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_ast-Tuple{OpenQASM.Types.MainProgram, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_ast","text":"trans_ast(ast::MainProgram, state_vector::StateVector, num_qubits::Int64)::MainProgram\n\ntransform the dynamic primitives to unveil the underlying unitary functionality\n\nHow\n\nOvercome resets\nApply the /defered measurement principle/\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_if_stmt-Tuple{OpenQASM.Types.IfStmt, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_if_stmt","text":"trans_if_stmt(stmt, state_vector, section)\n\ntransforms the qargs of a IfStmt\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_prog-Tuple{Any, StateVector, Int64, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_prog","text":"trans_prog(a::Any, state_vector::StateVector, num_qubits::Int, section::Int)::Any\n\nPattern matches a Prog element and returns it with the new address, based on the transformation from the StateVector\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_qop-Tuple{OpenQASM.Types.CXGate, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_qop","text":"trans_qop(cx::CXGate, state_vector::StateVector, section::Int)::CXGate\n\ntransforms the adresses of a CXGate based on the state vector and section in the dynamic circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_qop-Tuple{OpenQASM.Types.Instruction, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_qop","text":"trans_qop(inst::Instruction, state_vector::StateVector, section::Int)::Instruction\n\ntransforms the adresses of a quantum operation based on the state vector and section in the dynamic circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_qop-Tuple{OpenQASM.Types.Measure, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_qop","text":"trans_qop(m::Measure, state_vector::StateVector, section::Int)::Measure\n\ntransforms the adresses of a Meausment Operation based on the state vector and section in the dynamic circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_qop-Tuple{OpenQASM.Types.Reset, StateVector, Int64}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_qop","text":"trans_qop(r::Reset, state_vector::StateVector, section::Int)::Reset\n\nReturn the Reset Operation unchanged\n\nFIXME check if this is according to specifaction\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.trans_regdecl-Tuple{OpenQASM.Types.RegDecl, Integer}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.trans_regdecl","text":"trans_regdecl(reg::RegDecl, num_qubits::Integer)::RegDecl\n\nSets num_qubits bits as the number of bits in a quantum RegDecl\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#DynamicQuantumCircuits.Transformations.zip_prog_section-Tuple{Vector{Any}}","page":"Internal APIs for developers","title":"DynamicQuantumCircuits.Transformations.zip_prog_section","text":"zip_prog_section(progs::Vector{Any})\n\nZip the index of each section with a prog element. Increment index after each Measure\n\n\n\n\n\n","category":"method"},{"location":"man/internal/","page":"Internal APIs for developers","title":"Internal APIs for developers","text":"```","category":"page"},{"location":"#DynamicQuantumCircuits.jl","page":"DynamicQuantumCircuits.jl","title":"DynamicQuantumCircuits.jl","text":"","category":"section"},{"location":"","page":"DynamicQuantumCircuits.jl","title":"DynamicQuantumCircuits.jl","text":"DynamicQuantumCircuits","category":"page"},{"location":"#DynamicQuantumCircuits","page":"DynamicQuantumCircuits.jl","title":"DynamicQuantumCircuits","text":"DynamicQuantumCircuits\n\n(Image: docsstable) (Image: Build Status)\n\nDynamicQuantumCircuits.jl is a Julia package that addresses the limitations of Noisy Intermediate-Scale Quantum (NISQ) hardware by reducing qubit count. In the NISQ era, the major challenge is efficiently mapping quantum algorithms to these noisy computers. The solution lies in analyzing whether quantum algorithms can be mapped to real hardware with fewer qubits, which was not possible until the introduction of Dynamic Quantum Circuits (DQC).\n\nDynamicQuantumCircuits is a package for:\n\n[X] Applying unitary_reconstruction to to obtain a static quantum circuit from a dynamic quantum circuit.\n[X] Verification of the equivalence between the DQC and the original static quantum circuit (SQC).\n[ ] Optimizing the qubit count of a static quantum circuit by converting it into a dynamic quantum circuit.\n\nStatic Quantum Circuits (SQC) are limited by a restricted number of qubits, shallow coherence, and low fidelity. In contrast, Dynamic Quantum Circuits (DQC) offer several advantages:\n\nMinimized qubit count by recycling qubits.\nImproved fidelity and more control.\n\nThe goal of this package is to provide a tool for researchers and developers working on quantum computing to optimize qubit usage and improve the performance of quantum algorithms on NISQ hardware.\n\nTo get started, you can install the package by running import Pkg; Pkg.add(\"DynamicQuantumCircuits\"). The full documentation is available online and can also be built locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"DynamicQuantumCircuits.jl","title":"DynamicQuantumCircuits.jl","text":"using DynamicQuantumCircuits","category":"page"},{"location":"#Latest-news","page":"DynamicQuantumCircuits.jl","title":"Latest news","text":"","category":"section"},{"location":"","page":"DynamicQuantumCircuits.jl","title":"DynamicQuantumCircuits.jl","text":"See the CHANGELOG.md","category":"page"},{"location":"#Getting-started","page":"DynamicQuantumCircuits.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"DynamicQuantumCircuits.jl","title":"DynamicQuantumCircuits.jl","text":"Start by having a look at the tutorial.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#tutorial","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"This tutorial will walk you through the main functionality of the DynamicQuantumCircuits.jl package. Specifically, we'll focus on converting a non-unitary optimized quantum circuit into an ideal unitary representation. Latter, we'll focus on verifying the equivalence between a unitary (static) quantum circuit and a non-unitary dynamic quantum circuit.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"First, let's load the required packages and define a sample dynamic quantum circuit:","category":"page"},{"location":"tutorial/#Circuit-conversion-Tutorial-copy-pastable-version","page":"DynamicQuantumCircuits.jl Tutorial","title":"Circuit conversion Tutorial - copy-pastable version","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"using OpenQASM\nusing DynamicQuantumCircuits\n\nbv_101_dynamic_qasm = \"\"\"\n  OPENQASM 2.0;\n  include \"qelib1.inc\";\n  qreg q[2];\n  creg c[3];\n  x q[1];\n  h q[0];\n  h q[1];\n  CX q[0],q[1];\n  h q[0];\n  measure q[0] -> c[0];\n  reset q[0];\n  h q[0];\n  h q[0];\n  measure q[0] -> c[1];\n  reset q[0];\n  h q[0];\n  CX q[0],q[1];\n  h q[0];\n  measure q[0] -> c[2];\n  \"\"\"\n\nbv_101_dynamic = OpenQASM.parse(bv_101_dynamic_qasm)\n\n# Convert the non-unitary optimized quantum circuit into an ideal unitary representation\n\nbv_101_dynamic = OpenQASM.parse(bv_101_dynamic_qasm)\n\nNow, we can use the `unitary_reconstruction` function to convert the\ndynamic quantum circuit into an ideal unitary representation:\n\nbv_101_unitary = DynamicQuantumCircuits.unitary_reconstruction(bv_101_dynamic)","category":"page"},{"location":"tutorial/#Input:-an-OpenQASM-file","page":"DynamicQuantumCircuits.jl Tutorial","title":"Input: an OpenQASM file","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"First we need to parse the string of the circuit description with OpenQASM","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"using OpenQASM\nbv_101_dynamic = OpenQASM.parse(\"\"\"\n    OPENQASM 2.0;\n    include \"qelib1.inc\";\n    qreg q[2];\n    creg c[3];\n    x q[1];\n    h q[0];\n    h q[1];\n    CX q[0],q[1];\n    h q[0];\n    measure q[0] -> c[0];\n    reset q[0];\n    h q[0];\n    h q[0];\n    measure q[0] -> c[1];\n    reset q[0];\n    h q[0];\n    CX q[0],q[1];\n    h q[0];\n    measure q[0] -> c[2];\n    \"\"\")","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Excellent, let's continue the tutorial and dive deeper into the unitary reconstruction process, focusing on how it overcomes resets and defers measurements.","category":"page"},{"location":"tutorial/#Unitary-Reconstruction","page":"DynamicQuantumCircuits.jl Tutorial","title":"Unitary Reconstruction","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"The unitary_reconstruction function in DynamicQuantumCircuits.jl is responsible for converting a non-unitary optimized quantum circuit (represented as an OpenQASM object) into an ideal unitary representation. This process involves several key steps:","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Removing Resets: Next, the function removes all reset operations from the circuit. This is done using the remove_resets function, which drops all Reset gates from the circuit's program.\nDeferring Measurements: After removing measurements and resets, the function defers all remaining measurements to the end of the circuit. This is done using the defeer_measurements function, which replaces any phase rotations controlled by measurement outcomes with phase gates controlled by the respective circuits.\nUnitary Reconstruction: Finally, the function performs the unitary reconstruction by converting the modified circuit into a unitary representation. This is the core of the unitary_reconstruction function, which ensures that the resulting circuit is a valid unitary operation.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"The key advantage of this approach is that it allows the DynamicQuantumCircuits.jl package to handle non-unitary circuits, such as those with resets and measurements, and convert them into an equivalent unitary representation. This is crucial for optimizing qubit usage and improving the performance of quantum algorithms on NISQ hardware.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"By removing measurements and resets, and deferring the remaining measurements, the unitary reconstruction process ensures that the final circuit is a valid unitary operation, which can then be used in further analysis and optimization.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Let's see the full unitary_reconstruction function in action:","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"using DynamicQuantumCircuits\nbv_101_unitary = unitary_reconstruction(bv_101_dynamic)","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"This will take the bv_101_dynamic circuit, remove measurements and resets, defer measurements, and then perform the unitary reconstruction to obtain the bv_101_unitary circuit, which is the ideal unitary representation of the original dynamic circuit.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Now that we have the unitary circuit, we can use the ZX-Calculus to verify its equivalence to the original dynamic circuit, as we did in the previous section.","category":"page"},{"location":"tutorial/#Equivalence-of-a-static-and-an-ideal-quantum-circuit","page":"DynamicQuantumCircuits.jl Tutorial","title":"Equivalence of a static and an ideal quantum circuit","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"To verify if the original circuit and the ideal circuit are equal, we can use the libary ZXCalculus.jl. The principle of quantum circuit equality relies on the reversibility and unitarity of quantum operations.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Every quantum operation is unitary and thus reversible. The product of any quantum operation and its  inverse (adjoint) will always yield the identity. For a matrix to be unitary, the following property must hold:","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"U cdot U^dagger = U^dagger cdot U = I_n  U in mathbbR^n times n","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"If U1 and U2 are unitary matrices, so is their matrix product U1 · U2. Unitary matrices preserve inner products, so if U is unitary, then for all V, V' ∈ ℂ^n we have:","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"U V U V   = V V  ","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"To verify the equality of two quantum circuits G1 and G2 with system matrices U1 and U2, we can check if there is no difference D = U1 · U2^† between the first and second quantum circuit. If tr(D) = 0, then U1 · U2^† = D = I, and the circuits are equal.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Let's use the ZX-Calculus to verify the equivalence of the static and dynamic circuits:","category":"page"},{"location":"tutorial/#Equivalence-Checking-copy-pastable-version","page":"DynamicQuantumCircuits.jl Tutorial","title":"Equivalence Checking - copy-pastable version","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"\nusing YaoHIR\nusing YaoHIR: BlockIR\nusing ZXCalculus\nusing ZXCalculus.ZX\n\nbv_101_static = OpenQASM.parse(\"\"\"\"\n  OPENQASM 2.0;\n  include \"qelib1.inc\";\n  qreg q[4];\n  creg c[3];\n  x q[3];\n  h q[0];\n  h q[1];\n  h q[2];\n  h q[3];\n  CX q[0],q[3];\n  CX q[2],q[3];\n  h q[0];\n  h q[1];\n  h q[2];\n  measure q[0] -> c[0];\n  measure q[1] -> c[1];\n  measure q[2] -> c[2];\n  \"\"\")\n\nbv_101_unitary = DynamicQuantumCircuits.unitary_reconstruction(bv_101_dynamic)\nbv_101_static = ZXDiagram(BlockIR(static))\n\nverify_equality(bv_101_dynamic, bv_101_static)","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"This will check if the two ZX-Diagrams representing the static and dynamic circuits are equal, using the powerful rewrite rules of the ZX-Calculus.","category":"page"},{"location":"tutorial/#Verifying-the-equivalence-of-static-and-dynamic-circuits","page":"DynamicQuantumCircuits.jl Tutorial","title":"Verifying the equivalence of static and dynamic circuits","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"To compare the original dynamic circuit and the reconstructed unitary circuit, we'll convert them both into ZX-Diagrams and use the verify_equality function to check if they are equivalent.","category":"page"},{"location":"tutorial/#Convert-the-Quantum-into-a-ZXDiagram","page":"DynamicQuantumCircuits.jl Tutorial","title":"Convert the Quantum into a ZXDiagram","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"Now, we can convert the static and unitary circuits into ZX-Diagrams and verify their equivalence:","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"using YaoHIR\nusing YaoHIR: BlockIR\nusing ZXCalculus\nusing ZXCalculus.ZX\n\nbv_101_static = OpenQASM.parse(\"\"\"\n  OPENQASM 2.0;\n  include \"qelib1.inc\";\n  qreg q[4];\n  creg c[3];\n  x q[3];\n  h q[0];\n  h q[1];\n  h q[2];\n  h q[3];\n  CX q[0],q[3];\n  CX q[2],q[3];\n  h q[0];\n  h q[1];\n  h q[2];\n  measure q[0] -> c[0];\n  measure q[1] -> c[1];\n  measure q[2] -> c[2];\n  \"\"\")\n\n\nbv_101_dynamic_qasm = OpenQASM.parse(\"\"\"\n  OPENQASM 2.0;\n  include \"qelib1.inc\";\n  qreg q[2];\n  creg c[3];\n  x q[1];\n  h q[0];\n  h q[1];\n  CX q[0],q[1];\n  h q[0];\n  measure q[0] -> c[0];\n  reset q[0];\n  h q[0];\n  h q[0];\n  measure q[0] -> c[1];\n  reset q[0];\n  h q[0];\n  CX q[0],q[1];\n  h q[0];\n  measure q[0] -> c[2];\n  \"\"\")\n\n\nbv_101_static_zx = ZXDiagram(BlockIR(bv_101_static))\nbv_101_unitary_zx = ZXDiagram(BlockIR(bv_101_unitary))\n\nverify_equality(bv_101_unitary_zx, bv_101_static_zx)","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"This will check if the two ZX-Diagrams representing the unitary and static circuits are equal, using the powerful rewrite rules of the ZX-Calculus. If the circuits are equivalent, the function will return true.","category":"page"},{"location":"tutorial/#Conclusion","page":"DynamicQuantumCircuits.jl Tutorial","title":"Conclusion","text":"","category":"section"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"In this tutorial, we've explored the key functionality of the DynamicQuantumCircuits.jl package, which addresses the limitations of Noisy Intermediate-Scale Quantum (NISQ) hardware by reducing qubit count. We've learned how to convert a non-unitary optimized quantum circuit into an ideal unitary representation using the unitary_reconstruction function.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"The unitary reconstruction process involves several important steps, such as removing measurements and resets, deferring measurements, and then performing the actual unitary reconstruction. This ensures that the resulting circuit is a valid unitary operation, which is crucial for optimizing qubit usage and improving the performance of quantum algorithms on NISQ hardware.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"We've also seen how to use the powerful ZX-Calculus to verify the equivalence of the static and dynamic circuits. By converting the circuits into ZX-Diagrams and using the verify_equality function, we can ensure that the original circuit and the reconstructed unitary circuit are indeed equivalent.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"The DynamicQuantumCircuits.jl package provides a valuable tool for researchers and developers working on quantum computing, allowing them to optimize qubit usage and improve the performance of their quantum algorithms on NISQ hardware.","category":"page"},{"location":"tutorial/","page":"DynamicQuantumCircuits.jl Tutorial","title":"DynamicQuantumCircuits.jl Tutorial","text":"We hope this tutorial has been helpful in understanding the capabilities of the DynamicQuantumCircuits.jl package and how it can be used to address the challenges of the NISQ era. Happy coding!","category":"page"},{"location":"man/api/#APIs","page":"APIs","title":"APIs","text":"","category":"section"},{"location":"man/api/","page":"APIs","title":"APIs","text":"unitary_reconstruction\nvalidate_state","category":"page"},{"location":"man/api/#DynamicQuantumCircuits.unitary_reconstruction","page":"APIs","title":"DynamicQuantumCircuits.unitary_reconstruction","text":"unitary_reconstruction(qc_dynamic::MainProgram)::MainProgram\n\nReconstructs a unitary quantum circuit from a dynamic quantum circuit\n\n\n\n\n\n","category":"function"},{"location":"man/api/#DynamicQuantumCircuits.validate_state","page":"APIs","title":"DynamicQuantumCircuits.validate_state","text":"validate_state(upper::Vector{Any}, lower::Vector{Any})\n\nThe combined StateVector needs to be a Set\n\nTODO Check if the the states are increase by one\n\n\n\n\n\n","category":"function"}]
}
